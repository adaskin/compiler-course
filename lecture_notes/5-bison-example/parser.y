%{
#include <stdio.h>
#include <math.h>

void yyerror(char *);
int yylex(void);

%}

%union {
    double dval;
}

%token <dval> NUMBER
%token ADD SUB MUL DIV LPAREN RPAREN EOL

%type <dval> expression term factor

%left ADD SUB
%left MUL DIV
%right UMINUS

%%

input:
    /* empty */
    | input line
;

line:
    EOL
    | expression EOL { printf("= %g\n", $1); }
;

expression:
    term
    | expression ADD term { $$ = $1 + $3; }
    | expression SUB term { $$ = $1 - $3; }
;

term:
    factor
    | term MUL factor { $$ = $1 * $3; }
    | term DIV factor { $$ = $1 / $3; }
;

factor:
    NUMBER
    | LPAREN expression RPAREN { $$ = $2; }
    | SUB factor %prec UMINUS { $$ = -$2; }
;

%%

void yyerror(char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

int main(void) {
    printf("Simple Calculator - Enter expressions or Ctrl-D to exit\n");
    yyparse();
    return 0;
}

/*
yylex()
Purpose: Called by parser to get next token
Returns: Integer token code, Sets yylval with token value
Source: Generated by Flex from lexer.l

yyparse()
Purpose: Main parsing function
Behavior: Calls yylex() repeatedly, applies grammar rules
Returns: 0 on success, 1 on syntax error
Source: Generated by Bison from parser.y

yylval
Type: YYSTYPE (defined by %union in Bison)
Purpose: Carries semantic values from lexer to parser
Usage: Flex sets it, Bison accesses via $1, $2, etc.

yyerror(char *msg)
Purpose: Error reporting function
Called by: Parser when syntax errors occur
Must be implemented by user
*/