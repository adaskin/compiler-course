# Clean everything
```bash
rm -f calculator *.o lex.yy.c parser.tab.*
```

# Generate and compile
```bash
bison -d parser.y
flex lexer.l
gcc -c ast.c
gcc -c codegen.c  
gcc -c parser.tab.c
gcc -c lex.yy.c
gcc -o calculator parser.tab.o lex.yy.o ast.o codegen.o -lm
```
# Test
```
echo "2 + 3 * 4" | ./calculator
```

# Explanation: How the code generation, bytecode, and stack machine work together in our calculator
*Taken from DeepSeek*
 
## 1. Overall Architecture

```
Source Code → Lexer → Parser → AST → Code Generator → Bytecode → Stack Machine → Result
     ↓          ↓        ↓       ↓          ↓            ↓           ↓           ↓
   "2+3*4"   tokens   syntax   tree     instructions   PUSH 2     stack ops     14
```

## 2. Code Generation Process

### From AST to Bytecode

The code generator walks the AST and emits instructions in **post-order traversal** (left, right, node).

**Example: `2 + 3 * 4`**

AST Structure:
```
    ADD
    / \
   2   MUL
      / \
     3   4
```

Code Generation Steps:
1. Process left child of ADD (2) → `PUSH 2`
2. Process right child of ADD (MUL):
   - Process left child of MUL (3) → `PUSH 3`
   - Process right child of MUL (4) → `PUSH 4`
   - Process MUL node → `MUL`
3. Process ADD node → `ADD`

**Generated Bytecode:**
```
0: PUSH 2
1: PUSH 3  
2: PUSH 4
3: MUL
4: ADD
```

## 3. Bytecode Instructions

Our instruction set is simple but complete:

```c
typedef enum {
    OP_PUSH,    // Push number to stack
    OP_ADD,     // Add top two stack values
    OP_SUB,     // Subtract top two stack values  
    OP_MUL,     // Multiply top two stack values
    OP_DIV,     // Divide top two stack values
    OP_NEG,     // Negate top stack value
    OP_POW      // Power (top-1)^top
} OpCode;
```

Each instruction is stored as:
```c
typedef struct {
    OpCode opcode;
    double operand;  // Only used for OP_PUSH
} Instruction;
```

## 4. Stack Machine Execution

The stack machine has:
- **Instruction Pointer (IP)**: Points to current instruction
- **Stack Pointer (SP)**: Points to top of stack
- **Stack Array**: Holds intermediate values

### Execution of `2 + 3 * 4`

```
Bytecode: PUSH 2, PUSH 3, PUSH 4, MUL, ADD

Step 0: PUSH 2 → Stack: [2]
Step 1: PUSH 3 → Stack: [2, 3]  
Step 2: PUSH 4 → Stack: [2, 3, 4]
Step 3: MUL    → Stack: [2, 12]  (pop 3,4 → 3*4=12 → push 12)
Step 4: ADD    → Stack: [14]     (pop 2,12 → 2+12=14 → push 14)
```
Let's trace through the execution:

**Initial State:**
```
Stack: [ ]
SP = -1 (empty stack)
```

**Step 0: PUSH 2**
```
Instruction: PUSH 2
Stack: [2]
SP = 0
```

**Step 1: PUSH 3**
```
Instruction: PUSH 3  
Stack: [2, 3]
SP = 1
```

**Step 2: PUSH 4**
```
Instruction: PUSH 4
Stack: [2, 3, 4]
SP = 2
```

**Step 3: MUL**
```
Instruction: MUL
Operation: stack[SP-1] * stack[SP] = 3 * 4 = 12
Stack: [2, 12]  // Pop two, push result
SP = 1
```

**Step 4: ADD**
```
Instruction: ADD
Operation: stack[SP-1] + stack[SP] = 2 + 12 = 14
Stack: [14]  // Pop two, push result
SP = 0
```

**Final Result:** `14` on stack

## 5. More Complex Example

**Expression: `(2 + 3) * 4`**

AST:
```
    MUL
    / \
  ADD   4
  / \
 2   3
```

Bytecode:
```
0: PUSH 2
1: PUSH 3
2: ADD      // (2+3) = 5
3: PUSH 4  
4: MUL      // 5 * 4 = 20
```

Execution Trace:
```
Step 0: PUSH 2 → Stack: [2]
Step 1: PUSH 3 → Stack: [2, 3]  
Step 2: ADD    → Stack: [5]
Step 3: PUSH 4 → Stack: [5, 4]
Step 4: MUL    → Stack: [20]

```

## 6. Unary Operator Example

**Expression: `- (2 + 3)`**

AST:
```
    NEG
     |
    ADD
    / \
   2   3
```

Bytecode:
```
0: PUSH 2
1: PUSH 3
2: ADD  // 2+3=5
3: NEG  // -5
```

Execution:
```
Step 0: PUSH 2 → Stack: [2]
Step 1: PUSH 3 → Stack: [2, 3]
Step 2: ADD    → Stack: [5]  
Step 3: NEG    → Stack: [-5]
```

## 7. Exponentiation Example

**Expression: `2 ^ 3`**

Bytecode:
```
0: PUSH 2
1: PUSH 3
2: POW  // 2^3=8
```

Execution:
```
Step 0: PUSH 2 → Stack: [2]
Step 1: PUSH 3 → Stack: [2, 3]
Step 2: POW    → Stack: [8]  (using pow(2,3))
```

## 8. Implementation Code Walkthrough

### Code Generation (`codegen.c`)

```c
void codegen_generate_from_ast(Bytecode *bc, ASTNode *node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_NUMBER:
            // Emit PUSH instruction with the number
            codegen_emit(bc, OP_PUSH, node->value);
            break;
            
        case AST_ADD:
            // Generate code for left, then right, then ADD
            codegen_generate_from_ast(bc, node->left);
            codegen_generate_from_ast(bc, node->right);
            codegen_emit(bc, OP_ADD, 0);
            break;
            
        // ... similar for other operators
    }
}
```

### Stack Machine (`codegen.c`)

```c
void codegen_execute(Bytecode *bytecode) {
    double stack[256];
    int sp = -1;  // Stack pointer
    
    for (int ip = 0; ip < bytecode->size; ip++) {
        Instruction instr = bytecode->code[ip];
        
        switch (instr.opcode) {
            case OP_PUSH:
                stack[++sp] = instr.operand;
                break;
                
            case OP_ADD:
                stack[sp-1] = stack[sp-1] + stack[sp];
                sp--;
                break;
                
            // ... similar for other operations
        }
    }
}
```

## 9. Why Use a Stack Machine?

**Advantages:**
- **Simple**: Easy to implement and understand
- **Compact**: Bytecode is smaller than source code
- **Portable**: Same bytecode can run on different machines
- **Efficient**: Direct execution without tree traversal

**Real-world Examples:**
- **Java**: JVM (Java Virtual Machine) uses stack architecture
- **Python**: CPython bytecode interpreter
- **.NET**: Common Language Runtime (CLR)
- **WebAssembly**: Stack-based virtual machine

## 10. Complete Execution Pipeline

Let's trace `2 + 3 * 4` through the entire system:

1. **Source**: `"2 + 3 * 4"`
2. **Lexer**: `NUM(2) '+' NUM(3) '*' NUM(4)`
3. **Parser**: Builds AST: `ADD(NUM(2), MUL(NUM(3), NUM(4)))`
4. **Code Generator**: 
   - Visit NUM(2) → `PUSH 2`
   - Visit MUL: 
     - Visit NUM(3) → `PUSH 3`
     - Visit NUM(4) → `PUSH 4` 
     - Emit `MUL`
   - Emit `ADD`
5. **Bytecode**: `[PUSH 2, PUSH 3, PUSH 4, MUL, ADD]`
6. **Stack Machine**:
   ```
   PUSH 2: stack = [2]
   PUSH 3: stack = [2, 3] 
   PUSH 4: stack = [2, 3, 4]
   MUL:    stack = [2, 12]  (3*4=12)
   ADD:    stack = [14]     (2+12=14)
   ```
7. **Result**: `14`

