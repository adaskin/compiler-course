- [**Project 2: Parser and AST Generation**](#project-2-parser-and-ast-generation)
  - [**1. Objective**](#1-objective)
  - [**2. Tools and Language Freedom**](#2-tools-and-language-freedom)
  - [**3. Deliverables**](#3-deliverables)
  - [**4. Updating Project 1 Lexer**](#4-updating-project-1-lexer)
  - [**5. Resources and Example Grammars**](#5-resources-and-example-grammars)
  - [**6. Project Series \& Grading**](#6-project-series--grading)
  - [**7. Policy on AI Tools and Language Evolution**](#7-policy-on-ai-tools-and-language-evolution)
  - [**Quick Start Guide: Building Your Parser with AST**](#quick-start-guide-building-your-parser-with-ast)
    - [**1. Understand the Project Structure**](#1-understand-the-project-structure)
    - [**2. Study the Example Files**](#2-study-the-example-files)
    - [**3. Build Process**](#3-build-process)
    - [**4. Adapt for Your Language**](#4-adapt-for-your-language)
    - [**5. Test Incrementally**](#5-test-incrementally)
    - [**6. Common Pitfalls \& Solutions**](#6-common-pitfalls--solutions)
    - [**7. Beyond the Calculator**](#7-beyond-the-calculator)
    - [**8. Next Steps**](#8-next-steps)

# **Project 2: Parser and AST Generation**
*written with the help of DeepSeek*
## **1. Objective**

The goal of this project is to build upon the lexical analyzer (lexer) from Project 1 and implement the next phase of your compiler: the **parser**. Your parser will take the sequence of tokens generated by your lexer and determine if it conforms to the syntactic rules (grammar) of your chosen programming language. Upon a successful parse, your program must construct an **Abstract Syntax Tree (AST)** that represents the hierarchical syntactic structure of the source code.

This project will deepen your understanding of context-free grammars, parsing algorithms, and the central role of the AST in a compiler's pipeline.

## **2. Tools and Language Freedom**

You have significant freedom in your implementation choices, as in Project 1.

*   **Implementation Language:** You may use any programming language you are comfortable with (e.g., Python, C, C++, Java, OCaml, Rust, etc.).
*   **Parser Implementation Method:** You can choose one of the following approaches:
    *   **Parser Generators (Recommended):** Use a tool to generate a parser from a formal grammar specification.
        *   Examples: **Bison** (C/C++), **ANTLR** (Java, C++, etc.), **JavaCC** (Java), **PLY** (Python), **Menhir** or **Ocamlyacc** (OCaml).
    *   **Handwritten Parser:** You may also write a recursive-descent or other parsing algorithm entirely by hand, without using a generator.
*   **Grammar Property:** Pay close attention to the grammar class supported by your chosen tool (e.g., LALR(1), LR(1), LL(*)). Ensure your language's grammar is compatible, or be prepared to refactor it.

## **3. Deliverables**

You are required to submit the following:

1.  **Source Code:** The complete, well-commented source code for your parser and the updated lexer from Project 1.
2.  **A `README.md` File:** This file must include:
    *   Instructions on how to build and run your parser.
    *   A clear, concise description of your chosen programming language's syntax.
    *   The grammar you implemented (in EBNF or a similar notation).
    *   A description of your AST node structure (e.g., class hierarchy in OOP, or type definitions in functional languages).
3.  **Test Cases:** A suite of test files that demonstrate your parser's capabilities. Include:
    *   **Valid programs** that cover a wide range of syntactic constructs (declarations, expressions, control flow, etc.).
    *   **Invalid programs** that contain syntactic errors. Your parser should gracefully reject these with appropriate error messages.
4.  **Output:** For each valid test case, your program should output a representation of the generated AST. This can be:
    *   A textual representation (e.g., LISP-style S-expressions, a indented tree, or JSON).
    *   A visualization (e.g., using Graphviz's DOT language).
    *   *(Clarification: The primary goal is to build the AST in memory. The output is for demonstration and grading purposes.)*

## **4. Updating Project 1 Lexer**

You will almost certainly need to update your Project 1 lexer. This is expected and part of the process. Common reasons include:
*   Discovering new tokens needed for the full grammar.
*   Adjusting token definitions based on parser feedback (e.g., handling operator precedence or keywords).
*   Integrating the lexer as a component that feeds tokens to the parser.

## **5. Resources and Example Grammars**

To help you design your language's grammar, you can study these real-world examples:
*   **miniJava Grammar:** A simplified Java grammar. A hand-written parser in Java is available [here](https://www.cambridge.org/us/features/052182060X/). Excellent for seeing a complete, small-scale example.
*   **Python Full Grammar:** The official grammar specification for Python 3 [here](https://docs.python.org/3/reference/grammar.html). Useful for understanding a more complex, production-grade grammar.

## **6. Project Series & Grading**

This project is the second part of a continuous compiler implementation. Your work will be evaluated as a whole at the end of the semester, but this project has its own specific grade.

*   **Project 1:** Lexer
*   **Project 2:** Parser & AST Generation **(This Project)**
*   **Project 3:** Intermediate Code Generation (e.g., LLVM IR, custom representation, or Assembly)

**Grading Rubric for Project 2:**
*   **Correctness (40%):** The parser correctly accepts valid programs and rejects invalid ones with clear errors.
*   **AST Construction (30%):** A well-designed, logically structured AST is built for all valid input programs.
*   **Completeness & Test Suite (20%):** The parser and AST cover a significant and representative portion of your language's grammar. Test cases are comprehensive.
*   **Code Quality, Documentation, and Build Instructions (10%):** Code is clean, commented, and the `README.md` provides all necessary information.

## **7. Policy on AI Tools and Language Evolution**

*   **AI Tools:** You are permitted to use all AI-assisted tools (e.g., DeepSeek, GitHub Copilot) for brainstorming, boilerplate code, or debugging. **However,** you must understand and be able to explain any code you submit. The primary learning experience is your responsibility.
*   **Language Evolution:** You are allowed to refine and change the specification of your programming language as the semester progresses. This is a natural part of language design. Please document any significant changes in your project submissions.


## **Quick Start Guide: Building Your Parser with AST**

Based on the [example calculator](../lecture_notes/5-bison-example/with_ast/) we built in class, here's a step-by-step guide to help you start Project 2. The files (`ast.h`, `ast.c`, `lexer.l`, `parser.y`) provide a complete working example of a calculator that builds and evaluates an AST.

### **1. Understand the Project Structure**

Your parser project should have these core components:

```
your_compiler/
├── ast.h          # AST node definitions and types
├── ast.c          # AST creation/evaluation functions  
├── lexer.l        # Flex lexer specification
├── parser.y       # Bison parser specification
└── Makefile       # Build instructions (recommended)
```

### **2. Study the Example Files**

**`ast.h`** - Defines your AST structure:
- `ASTNodeType` enum: All possible node types in your language
- `ASTNode` struct: The actual node with type, value, and child pointers

**`ast.c`** - Implements AST operations:
- Constructor functions: `ast_create_number()`, `ast_create_binary()`, `ast_create_unary()`
- Evaluator: `ast_evaluate()` - traverses and computes values
- Utilities: `ast_print()`, `ast_free()` - for debugging and memory management

**`lexer.l`** - Token definitions:
- Regular expressions for each token type
- Returns tokens to parser using `yylval`
- Note how it includes `parser.tab.h` for token definitions

**`parser.y`** - Grammar rules and AST construction:
- `%union` defines what data each token/nonterminal carries
- Grammar rules create AST nodes using your constructors
- Precedence rules resolve ambiguity

### **3. Build Process**

For the calculator example, the build steps are:

```bash
# Generate parser and lexer C code
bison -d parser.y    # Generates parser.tab.c and parser.tab.h
flex lexer.l         # Generates lex.yy.c

# Compile everything together
gcc -o calculator parser.tab.c lex.yy.c ast.c -lm
```

**Pro Tip:** Create a `Makefile` to automate this!

### **4. Adapt for Your Language**

**Step 1: Define Your AST Structure**
- Extend `ASTNodeType` with your language constructs (variables, functions, control flow, etc.)
- Modify `ASTNode` struct to hold necessary information

**Step 2: Write AST Constructor Functions**
- Create functions like `ast_create_if()`, `ast_create_function()`, `ast_create_assignment()`

**Step 3: Update Lexer**
- Add tokens for your language keywords and symbols
- Ensure token values are properly stored in `yylval`

**Step 4: Write Grammar Rules**
- Each production rule should build the appropriate AST node
- Follow the pattern: `rule: components { $$ = create_node(...); }`

### **5. Test Incrementally**

Start simple and build up:
1. Get basic arithmetic working (like the calculator)
2. Add variable declarations
3. Add control structures (if/while)
4. Add functions

### **6. Common Pitfalls & Solutions**

**Memory Management:** Always free your AST with `ast_free()` after use.

**Precedence Issues:** Use Bison's `%left`, `%right`, `%precedence` directives to resolve operator precedence conflicts.

**Debugging:** Use `ast_print()` to visualize your AST and verify the structure is correct.

### **7. Beyond the Calculator**

The calculator only handles expressions. For a real programming language, you'll need to add:

- **Statements** (assignments, declarations, control flow)
- **Declarations** (variables, functions)
- **Scoping** (which will matter more in Project 3)
- **Type information** (if your language is typed)

### **8. Next Steps**

Once your parser is working and building correct ASTs, you're ready for Project 3 (code generation). The AST you build now will be the input for your code generator.

**Remember:** The calculator example is minimal - your language will be much more complex, but the fundamental principles are the same!

